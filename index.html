<!doctype html>
<html lang="en">
<head>

<style id="hide-score-remaining">
  #score,
  #remain,
  #qScoreLive,
  #qRemaining {
    display: none !important;
  }
</style>

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ATPL Question Bank</title>
<style>
  :root{--bg:#0b0b0b;--bg-soft:#141414;--card:#111315;--text:#fff;--muted:#9ca3af;--border:#262626;--ok:#22c55e;--bad:#ef4444;--flag:#f59e0b;--answered-exam:#6b7280;--qbox-bg:#e9f6fb;--qbox-text:#0b0b0b;}
  body.light{--bg:#f6f7f9;--bg-soft:#fff;--card:#fff;--text:#0b0b0b;--muted:#4b5563;--border:#e5e7eb;--answered-exam:#9ca3af;}
  *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .container{max-width:1280px;margin:0 auto;padding:16px 24px}
  .topbar{position:sticky;top:0;z-index:10;background:color-mix(in oklab, var(--bg) 85%, transparent);backdrop-filter:blur(8px);border-bottom:1px solid var(--border)}
  .header{display:flex;justify-content:space-between;align-items:center;gap:12px}
  .hstack{display:flex;align-items:center;gap:12px} .vstack{display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:16px}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:var(--bg-soft);color:var(--muted);font-size:12px}
  .button,.input,.select{padding:10px 12px;border-radius:12px;border:1px solid var(--border);background:var(--bg-soft);color:var(--text)}
  .button.primary{background:linear-gradient(135deg,#3f3f46,#52525b);border:none;color:#fff;cursor:pointer}
  .button:disabled{opacity:.6;cursor:not-allowed}
  .mode-buttons{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .mode-btn{padding:20px;border:2px solid var(--border);border-radius:14px;background:var(--bg-soft);cursor:pointer}
  .mode-btn.active{border-color:#22c55e}
  .grid{display:grid;gap:16px} .grid-2{grid-template-columns:1fr 1fr} .grid-3{grid-template-columns:240px 1fr 320px}
  @media (max-width: 1024px){.grid-3{grid-template-columns:1fr}}
  .question-box{background:var(--qbox-bg);border-radius:10px;padding:24px;color:var(--qbox-text)}
  .option-list{list-style:none;margin:0;padding:0} .option-list li{margin:8px 0;display:flex;gap:10px;align-items:center}
  .grid-pager{display:grid;grid-template-columns:repeat(auto-fill,minmax(36px,1fr));gap:8px}
  .pager-btn{padding:8px;border:1px solid var(--border);border-radius:8px;background:var(--bg-soft);color:var(--text);font-size:12px;cursor:pointer}
  .pager-btn.active{outline:2px solid #777} .pager-btn.correct{border-color:var(--ok)} .pager-btn.incorrect{border-color:var(--bad)}
  .pager-btn.answered-exam{border-color:var(--answered-exam);color:var(--answered-exam)} .pager-btn.flagged{box-shadow:0 0 0 2px color-mix(in oklab, var(--flag) 60%, transparent);border-color:var(--flag)}
  .hidden{display:none!important} .small{color:var(--muted);font-size:12px}
  .feedback-inline{margin-top:12px;padding:10px 12px;border-radius:10px;background:rgba(34,197,94,.12);color:#22c55e}
  .feedback-inline.bad{background:rgba(239,68,68,.12);color:#ef4444}
</style>
</head>
<body>
<!-- LOGIN -->
<div id="loginOverlay" style="position:fixed;inset:0;background:rgba(0,0,0,.88);display:flex;align-items:center;justify-content:center;z-index:9999">
  <div style="width:360px;max-width:94%;background:#111;border-radius:12px;padding:20px;color:#fff">
    <h2 style="margin:0 0 8px 0;font-size:20px">Enter access code</h2>
    <input id="loginInput" type="password" placeholder="Password" class="input" style="width:100%;margin-bottom:10px;background:#0e0e0e"/>
    <div class="hstack">
      <button id="loginBtn" class="button primary" style="flex:1">Enter</button>
      <button id="loginCancelBtn" class="button" style="flex:1">Exit</button>
    </div>
    <p id="loginError" style="color:#fca5a5;font-size:13px;margin-top:10px;display:none">Incorrect password. Try again.</p>
    <p class="small" style="margin-top:8px">Client-side protection. Use server-side auth for stronger security.</p>
  </div>
</div>

<div class="container" id="menu">
  <div class="vstack" style="max-width:980px;margin:36px auto">
    <h1 style="margin:0">ATPL Question Bank</h1>
    <div class="small">Version <strong>v1.8.5</strong> ‚Äî ST aliasing incl. <strong>ASP ‚Üí AEP</strong>; multi-select.</div>
    <div class="grid grid-2" style="margin-top:12px">
      <section class="card vstack">
        <h3 style="margin:0">Setup</h3>
        <label class="small">Subject</label>
        <select class="select" id="mSubject"><option selected disabled>Loading‚Ä¶</option></select>
        <div class="small" id="mSubjectInfo"></div>
        <div class="small" id="mSTInfo" style="display:none"></div>
        <label class="small" style="margin-top:4px"><input type="checkbox" id="mShuffle" checked> Shuffle questions</label>
        <label class="small" style="margin-top:4px"><input type="checkbox" id="mShuffleAnswers" checked> Shuffle answers</label>
        <label class="small">Number of questions</label>
        <input class="input" id="mCount" type="number" min="1" value="50" />
        <label class="small">Duration (minutes)</label>
        <input class="input" id="mMinutes" type="number" min="0" value="60" />
        <label class="small">Auto-advance (Test mode)</label>
        <select class="select" id="mAdvance"><option value="0">Off</option><option value="600" selected>Normal (600 ms)</option><option value="250">Fast (250 ms)</option></select>
        <label class="small">Mode</label>
        <div class="mode-buttons">
          <div class="mode-btn active" id="btnTest"><strong>Test Mode</strong><div class="small">Instant feedback</div></div>
          <div class="mode-btn" id="btnST"><strong>ST Mode</strong><div class="small">Fixed count & timer</div></div>
        </div>
        <button class="button primary" id="mStart">Start</button>
      </section>
      <section class="card vstack">
        <h3 style="margin:0">Notes</h3>
        <div class="small">‚Ä¢ Codes like ALW/OPR/HPL‚Ä¶ and <strong>ASP</strong> resolve to correct ST plans.</div>
        <div class="small">‚Ä¢ Multi-select questions: checkboxes + Confirm; exact-set scoring.</div>
        <div class="small">‚Ä¢ Finish enabled only when all questions are answered.</div>
      </section>
    </div>
  </div>
</div>

<div id="quiz" class="hidden">
  <div class="topbar">
    <div class="container">
      <div class="header">
        <div class="hstack">
          <button class="button" id="qBack">Menu</button>
          <h2 style="margin:0;font-size:18px">ATPL ‚Äî <span id="qSubject">Subject</span> <span id="qModeLabel" class="small" style="margin-left:8px;opacity:.7"></span></h2>
        </div>
        <div class="hstack">
          <span class="badge" id="qScoreLive">Score 0/0</span>
          <span class="badge" id="qRemaining">Remaining 0</span>
          <span class="badge" id="qTimer">--:--</span>
          <span class="badge" id="qProgress">0 / 0</span>
          <span class="badge hidden" id="qPlan">ST: -- Q ‚Ä¢ -- min</span>
          <button class="button" id="logoutBtn">Logout</button>
        </div>
      </div>
    </div>
  </div>

  <div class="container grid grid-3" style="margin-top:16px">
    <aside class="vstack">
      <div class="card vstack">
        <h3 style="margin:0">Question <span id="qNumber">‚Äî</span></h3>
        <div class="small">Status: <strong id="qStatus">‚Äî</strong></div>
      </div>
    </aside>
    <main class="vstack">
      <section class="card">
        <div class="question-box" id="qBox">
          <p id="qText">Select a subject to begin.</p>
          <ul class="option-list" id="qOptions"></ul>
          <div class="hstack hidden" id="qMultiControls" style="margin-top:8px;justify-content:flex-end">
            <button class="button primary" id="qConfirm" disabled>Confirm Answer</button>
          </div>
        </div>
      </section>
      <div class="hstack" style="justify-content:space-between">
        <button class="button" id="qPrev" disabled>Previous</button>
        <div class="hstack">
          <button class="button" id="qFlagBtn" aria-pressed="false">üö© Flag</button>
          <button class="button" id="qNext" disabled>Next</button>
          <button class="button primary" id="qFinish" disabled title="Answer all questions to finish">Finish</button>
        </div>
      </div>
      <section class="card vstack hidden" id="qResults">
        <h3 style="margin:0">Results</h3>
        <div class="hstack">
          <div class="badge">Accuracy: <span id="qAccuracy" style="margin-left:6px">0% (0/0)</span></div>
          <div class="badge">Time used: <span id="qTimeUsed" style="margin-left:6px">00:00</span></div>
        </div>
        <div class="vstack small" id="qBreakdown" style="margin-top:8px"></div>
      </section>
    </main>
    <aside class="vstack">
      <div class="card vstack">
        <h3 style="margin:0">Navigation</h3>
        <div class="grid-pager" id="qPager"></div>
      </div>
    </aside>
  </div>
</div>

<script>
/*** LOGIN ***/
const PASSWORD_HASH = "d6d2cdd503133e8a5101ae7692216afb2b617d07661da596a6610c7bb224ac76"; // sha256("flysafe")
const AUTH_KEY = 'atpl_authenticated_v1';
async function sha256hex(str){const enc=new TextEncoder();const data=enc.encode(str);const hash=await crypto.subtle.digest('SHA-256',data);return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');}
async function tryLogin(){const val=document.getElementById('loginInput').value||'';const d=await sha256hex(val);if(d===PASSWORD_HASH){sessionStorage.setItem(AUTH_KEY,'1');hideLogin();}else{const e=document.getElementById('loginError');e.style.display='block';e.textContent='Incorrect password. Try again.';}}
function hideLogin(){const ov=document.getElementById('loginOverlay');if(ov)ov.remove();}
function ensureLogin(){if(sessionStorage.getItem(AUTH_KEY)==='1') hideLogin();}
document.getElementById('loginBtn').addEventListener('click',tryLogin);
document.getElementById('loginInput').addEventListener('keydown',e=>{if(e.key==='Enter')tryLogin();});
document.getElementById('loginCancelBtn').addEventListener('click',()=>{alert('Close this tab/window to exit.');});
ensureLogin();

/*** ELEMENTS ***/
const menu=document.getElementById('menu'),quiz=document.getElementById('quiz');
const mSubject=document.getElementById('mSubject'),mSubjectInfo=document.getElementById('mSubjectInfo'),mSTInfo=document.getElementById('mSTInfo');
const mCount=document.getElementById('mCount'),mMinutes=document.getElementById('mMinutes'),mShuffle=document.getElementById('mShuffle'),mAdvance=document.getElementById('mAdvance'),mShuffleAnswers=document.getElementById('mShuffleAnswers');
const btnTest=document.getElementById('btnTest'),btnST=document.getElementById('btnST'),mStart=document.getElementById('mStart');
const qBack=document.getElementById('qBack'),qSubject=document.getElementById('qSubject'),qTimer=document.getElementById('qTimer'),qProgress=document.getElementById('qProgress'),qScoreLive=document.getElementById('qScoreLive'),qRemaining=document.getElementById('qRemaining');
const qNumber=document.getElementById('qNumber'),qStatus=document.getElementById('qStatus'),qText=document.getElementById('qText'),qOptions=document.getElementById('qOptions');
const qPrev=document.getElementById('qPrev'),qNext=document.getElementById('qNext'),qFinish=document.getElementById('qFinish'),qPager=document.getElementById('qPager');
const qResults=document.getElementById('qResults'),qBreakdown=document.getElementById('qBreakdown');const qAccuracy=document.getElementById('qAccuracy'), qTimeUsed=document.getElementById('qTimeUsed');
const qFlagBtn=document.getElementById('qFlagBtn'); const logoutBtn=document.getElementById('logoutBtn'); const qModeLabel=document.getElementById('qModeLabel'); const qPlan=document.getElementById('qPlan');
const qMultiControls=document.getElementById('qMultiControls'); const qConfirm=document.getElementById('qConfirm');

/*** STATE ***/
let RAW=null,SUBJECT='',POOL=[],QUESTIONS=[],INDEX=0,ANSWERS=[],MODE='test';
let SCORE_CORRECT=0,QUESTIONS_ANSWERED=0,START_TS=null; let FLAGGED=[];
let TIMER_END=null, TIMER_IV=null;
let TEMP_SEL=[]; // per-question temporary selection for multi (array of arrays)

/*** ST CONFIGURATION (strict) ***/
const ST_CONFIG = {
  "Air Law": { count: 44, minutes: 60 }, 
  "Operational Procedures": { count: 42, minutes: 75 }, 
  "Human Performance": { count: 48, minutes: 90 }, 
  "Meteorology": { count: 84, minutes: 120 }, 
  "Communications": { count: 34, minutes: 60 }, 
  "Principles of Flight": { count: 46, minutes: 90 }, 
  "Instrumentation": { count: 60, minutes: 90 }, 
  "Mass and Balance": { count: 25, minutes: 75 }, 
  "Performance": { count: 45, minutes: 120 }, 
  "Flight Planning and Monitoring": { count: 42, minutes: 120 }, 
  "General Navigation": { count: 55, minutes: 135 }, 
  "Radio Navigation": { count: 66, minutes: 90 }, 
  "Aircraft General Knowledge": { count: 80, minutes: 120 }, 
  "Airframe Systems, Electrics, Powerplant": { count: 80, minutes: 120 },
  // Direct ASP key as a safety net (same plan as AEP)
  "ASP": { count: 80, minutes: 120 }
};

/*** SUBJECT ALIASES (codes/variants ‚Üí canonical ST subject) ***/
const SUBJECT_ALIASES = {
  // Core
  "alw":"Air Law","law":"Air Law","airlaw":"Air Law",
  "opr":"Operational Procedures","operationalprocedures":"Operational Procedures",
  "hpl":"Human Performance","humanperformance":"Human Performance",
  "met":"Meteorology","meteorology":"Meteorology",
  "com":"Communications","communications":"Communications",
  "pof":"Principles of Flight","principlesofflight":"Principles of Flight",
  "ins":"Instrumentation","instrumentation":"Instrumentation",
  "mas":"Mass and Balance","mnb":"Mass and Balance","massandbalance":"Mass and Balance",
  "per":"Performance","performance":"Performance",
  "fpm":"Flight Planning and Monitoring","flightplanning":"Flight Planning and Monitoring","planningandmonitoring":"Flight Planning and Monitoring","flightplanningandmonitoring":"Flight Planning and Monitoring",
  "gnav":"General Navigation","gen":"General Navigation","generalnavigation":"General Navigation",
  "rnav":"Radio Navigation","rnv":"Radio Navigation","radionavigation":"Radio Navigation",
  "agk":"Aircraft General Knowledge","aircraftgeneralknowledge":"Aircraft General Knowledge",
  "aep":"Airframe Systems, Electrics, Powerplant","airframesystemselectricspowerplant":"Airframe Systems, Electrics, Powerplant","airframesystems":"Airframe Systems, Electrics, Powerplant","systems":"Airframe Systems, Electrics, Powerplant",
  // Your combined subject
  "asp":"Airframe Systems, Electrics, Powerplant"
};

function normKey(s){ return String(s).toLowerCase().replace(/[^a-z]/g,''); }
function canonicalSubject(subject){
  const k = normKey(subject);
  // Exact key name in ST_CONFIG (normalized)
  for (const stKey of Object.keys(ST_CONFIG)){
    if (normKey(stKey) === k) return stKey;
  }
  // Alias map
  if (SUBJECT_ALIASES[k]) return SUBJECT_ALIASES[k];
  return subject;
}
function defaultPlan(subject){
  const total = (RAW && RAW[subject]) ? (RAW[subject].length||0) : 0;
  const count = Math.min(50, Math.max(10, total));
  const minutes = Math.max(30, Math.round(count * 1.2));
  return {count, minutes};
}
function getPlanForSubject(subject){
  const can = canonicalSubject(subject);
  return Object.prototype.hasOwnProperty.call(ST_CONFIG, can) ? ST_CONFIG[can] : defaultPlan(subject);
}
function hasStrictPlan(subject){
  const can = canonicalSubject(subject);
  return Object.prototype.hasOwnProperty.call(ST_CONFIG, can);
}

/*** UTILS ***/
function toTextSet(arr){ return new Set(arr.map(x=>String(x))); }
function setsEqual(a,b){ if(a.size!==b.size) return false; for(const v of a){ if(!b.has(v)) return false; } return true; }

function normalize(q){
  let rawOptions = q.choices || q.answers || [];
  let options = [];
  let correctTexts = [];

  if (rawOptions.length && typeof rawOptions[0] === 'object') {
    rawOptions.forEach(o => {
      const text = o.text != null ? String(o.text) : String(o.label || o.value || '');
      options.push(text);
      if (o.correct === true || o.isCorrect === true) correctTexts.push(text);
    });
  } else {
    options = rawOptions.map(o => String(o));
    let corr = (q.answer !== undefined) ? q.answer : (q.correct_answers || q.correct_answer);
    if (Array.isArray(corr)) {
      corr.forEach(c => {
        if (typeof c === 'number' && options[c] != null) correctTexts.push(String(options[c]));
        else if (typeof c === 'string' && /^[A-Za-z]$/.test(c)) {
          const idx = c.toUpperCase().charCodeAt(0) - 65; if (options[idx] != null) correctTexts.push(String(options[idx]));
        } else { correctTexts.push(String(c)); }
      });
    } else {
      if (typeof corr === 'number' && options[corr] != null) correctTexts.push(String(options[corr]));
      else if (typeof corr === 'string' && /^[A-Za-z]$/.test(corr)) {
        const idx = corr.toUpperCase().charCodeAt(0) - 65; if (options[idx] != null) correctTexts.push(String(options[idx]));
      } else if (corr != null) { correctTexts.push(String(corr)); }
    }
  }

  const correctSet = toTextSet(correctTexts);
  const multi = correctSet.size > 1;
  return { text: q.question, options: [...options], correct: correctTexts[0] || null, correctSet, multi, explanation: q.explanation || null };
}

function fyShuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
function isAnswered(i){
  const v = ANSWERS[i];
  if (v == null) return false;
  return Array.isArray(v) ? v.length > 0 : true;
}
function isCorrect(i){
  const q=QUESTIONS[i],sel=ANSWERS[i];
  if (!isAnswered(i)) return false;
  if (q.multi){
    const selTexts = new Set((sel||[]).map(idx => String(q.options[idx])));
    return setsEqual(selTexts, q.correctSet);
  } else {
    return String(q.options[sel]) === String(q.correct);
  }
}
function fmtDur(ms){const s=Math.max(0,Math.floor(ms/1000));const h=Math.floor(s/3600);const m=Math.floor((s%3600)/60);const r=s%60;return h>0?`${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`:`${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`;}
function ensureTimerStopped(){ if(TIMER_IV){ clearInterval(TIMER_IV); TIMER_IV=null; }}

/*** PAGER ***/
function rebuildPager(){
  qPager.innerHTML='';
  QUESTIONS.forEach((_,i)=>{
    let cls='pager-btn'; if(i===INDEX) cls+=' active';
    if(isAnswered(i)){ if(MODE==='test') cls+= isCorrect(i)?' correct':' incorrect'; else cls+=' answered-exam'; }
    if(FLAGGED[i]) cls+=' flagged';
    const b=document.createElement('button'); b.className=cls; b.textContent=i+1;
    b.onclick=()=>{ INDEX=i; render(); };
    qPager.appendChild(b);
  });
}

/*** RENDER ***/
function render(){
  const total=QUESTIONS.length; const remaining = ANSWERS.filter((x,idx)=>!isAnswered(idx)).length;
  qProgress.textContent=`${Math.min(INDEX+1,total)} / ${total}`; qRemaining.textContent=`Remaining ${remaining}`;
  qNumber.textContent= total? INDEX+1 : '‚Äî'; qStatus.textContent=(isAnswered(INDEX)?'Answered':'Not answered');
  qPrev.disabled=INDEX===0; qNext.disabled=INDEX>=total-1;

  const q=QUESTIONS[INDEX]; qText.textContent=q? q.text : 'No questions';

  qFlagBtn.setAttribute('aria-pressed', String(FLAGGED[INDEX]===true));
  qFlagBtn.textContent = FLAGGED[INDEX] ? 'üö© Unflag' : 'üö© Flag';

  qOptions.innerHTML='';
  qMultiControls.classList.add('hidden');
  if(q){
    if(q.multi){
      const temp = Array.isArray(TEMP_SEL[INDEX]) ? TEMP_SEL[INDEX] : [];
      q.options.forEach((opt,i)=>{
        const li=document.createElement('li');
        const input=document.createElement('input');
        input.type='checkbox'; input.name='q'; 
        const answered = isAnswered(INDEX);
        const checked = answered ? (ANSWERS[INDEX]||[]).includes(i) : temp.includes(i);
        input.checked = checked;
        input.disabled = answered;
        input.addEventListener('change', ()=>{
          if(isAnswered(INDEX)) return;
          const cur = Array.isArray(TEMP_SEL[INDEX]) ? TEMP_SEL[INDEX] : [];
          if(input.checked){ if(!cur.includes(i)) cur.push(i); } else { const ix=cur.indexOf(i); if(ix>=0) cur.splice(ix,1); }
          TEMP_SEL[INDEX]=cur;
          qConfirm.disabled = !(cur.length>0);
        });
        const label=document.createElement('span'); label.textContent=' '+opt;
        li.appendChild(input); li.appendChild(label); qOptions.appendChild(li);
      });
      if(!isAnswered(INDEX)){
        qMultiControls.classList.remove('hidden');
        const cur = Array.isArray(TEMP_SEL[INDEX]) ? TEMP_SEL[INDEX] : [];
        qConfirm.disabled = !(cur.length>0);
        qConfirm.onclick = ()=>{
          if(isAnswered(INDEX)) return;
          const sel = Array.isArray(TEMP_SEL[INDEX]) ? TEMP_SEL[INDEX] : [];
          ANSWERS[INDEX] = sel.slice();
          if(MODE==='test'){
            const ok=isCorrect(INDEX);
            QUESTIONS_ANSWERED++; if(ok) SCORE_CORRECT++; qScoreLive.textContent=`Score ${SCORE_CORRECT}/${QUESTIONS_ANSWERED}`;
            showFeedback(ok, [...q.correctSet].join(', '), q.explanation);
            [...qOptions.querySelectorAll('input')].forEach(inp=>inp.disabled=true);
            qConfirm.disabled = true;
            const delay=parseInt(document.getElementById('mAdvance').value,10)||0; if(delay>0){ setTimeout(()=>{ if(INDEX<QUESTIONS.length-1){INDEX++;} render(); }, delay);} else { render(); }
          } else {
            render();
          }
        };
      }
    } else {
      q.options.forEach((opt,i)=>{
        const li=document.createElement('li');
        const input=document.createElement('input'); input.type='radio'; input.name='q';
        input.checked=(ANSWERS[INDEX]===i);
        input.onclick=()=>onSelectSingle(i);
        if(isAnswered(INDEX)) input.disabled=true;
        const label=document.createElement('span'); label.textContent=' '+opt;
        li.appendChild(input); li.appendChild(label); qOptions.appendChild(li);
      });
    }
  }

  const oldFb=document.querySelector('.feedback-inline'); if(oldFb) oldFb.remove();
  if(isAnswered(INDEX) && MODE==='test'){
    const ok=isCorrect(INDEX);
    const q=QUESTIONS[INDEX];
    const correctText = q.multi ? [...q.correctSet].join(', ') : q.correct;
    showFeedback(ok, correctText, q.explanation);
  }

  qFinish.disabled = remaining > 0;
  qFinish.title = remaining > 0 ? `Answer all questions first (${remaining} remaining)` : "Finish";

  rebuildPager();
}

function showFeedback(ok,correctText,explanation){
  const old=document.querySelector('.feedback-inline'); if(old) old.remove();
  const fb=document.createElement('div'); fb.className='feedback-inline'+(ok?'':' bad');
  fb.textContent= ok ? 'Correct!' : `Incorrect ‚Äî correct answer: ${correctText}`;
  if(!ok && explanation){ const ex=document.createElement('div'); ex.className='small'; ex.textContent=explanation; fb.appendChild(ex); }
  document.getElementById('qBox').appendChild(fb);
}

function onSelectSingle(i){
  const firstTime = !isAnswered(INDEX);
  ANSWERS[INDEX]=i;
  if(MODE==='test'){
    const ok=isCorrect(INDEX); 
    try{
      const q = (typeof QUESTIONS!=='undefined') ? QUESTIONS[INDEX] : null;
      if(q){
        const correctText = q.multi ? Array.from(q.correctSet||[]).join(', ') : (q.correct ?? '');
        if(typeof showFeedback === 'function'){ showFeedback(ok, correctText, q.explanation); }
      }
    }catch(e){}[...qOptions.querySelectorAll('input[type="radio"]')].forEach(inp=>inp.disabled=true);
    if(firstTime){ QUESTIONS_ANSWERED++; if(ok) SCORE_CORRECT++; qScoreLive.textContent=`Score ${SCORE_CORRECT}/${QUESTIONS_ANSWERED}`; }
    const delay=parseInt(document.getElementById('mAdvance').value,10)||0; if(delay>0){ setTimeout(()=>{ if(INDEX<QUESTIONS.length-1){INDEX++;} render(); }, delay);} else { render(); }
  } else { render(); }
}

qFlagBtn.addEventListener('click', ()=>{ if(!QUESTIONS.length) return; FLAGGED[INDEX]=!FLAGGED[INDEX]; render(); });

function finish(){
  ensureTimerStopped();
  let correct=0,answered=0; qBreakdown.innerHTML='';
  QUESTIONS.forEach((q,i)=>{
    const has=isAnswered(i); const ok=isCorrect(i);
    if(has){ answered++; if(ok) correct++; }
    const row=document.createElement('div'); row.innerHTML=`${ok?'<span style="color:#22c55e">‚úî</span>':(has?'<span style="color:#ef4444">‚úñ</span>':'<span style="color:#9ca3af">‚Ä¢</span>')} <strong>${i+1}.</strong> ${q.text}`; qBreakdown.appendChild(row);
  });
  const accPct=answered? Math.round(100*correct/answered):0; qAccuracy.textContent=`${accPct}% (${correct}/${answered})`;
  const usedMs=Math.max(0, Date.now() - (START_TS || Date.now())); qTimeUsed.textContent=fmtDur(usedMs);
  qResults.classList.remove('hidden');
}
qFinish.onclick=finish;

function startTimer(endTs){
  ensureTimerStopped(); TIMER_END=endTs;
  const tick=()=>{ const now=Date.now(); const remain=Math.max(0, TIMER_END? (TIMER_END-now):0); qTimer.textContent=fmtDur(remain); if(TIMER_END && now>=TIMER_END){ ensureTimerStopped(); finish(); } };
  TIMER_IV=setInterval(tick,1000); tick();
}

/*** SUBJECT LABELS + INFO ***/
function buildSubjectOptionLabel(subject, baseCount){
  if (btnST.classList.contains('active')){
    const p = getPlanForSubject(subject);
    return `${subject} ‚Äî ST: ${p.count} Q ‚Ä¢ ${p.minutes} min`;
  }
  return `${subject} (${baseCount})`;
}

function populateSubjects(){
  mSubject.innerHTML='<option selected disabled>Choose a subject</option>';
  Object.keys(RAW).forEach(s=>{
    const count=(RAW[s]||[]).length||0;
    const opt=document.createElement('option');
    opt.value=s; opt.textContent=buildSubjectOptionLabel(s, count);
    mSubject.appendChild(opt);
  });
}

function updateSubjectInfo(){
  if(!SUBJECT){ mSubjectInfo.textContent=''; mSTInfo.style.display='none'; return; }
  const total=(RAW[SUBJECT]||[]).length||0;
  mSubjectInfo.textContent = total + ' questions available';
  if(btnST.classList.contains('active')){
    const p=getPlanForSubject(SUBJECT);
    mSTInfo.style.display='block';
    mSTInfo.textContent = `ST for ${SUBJECT}: ${p.count} Q ‚Ä¢ ${p.minutes} min` + (hasStrictPlan(SUBJECT) ? '' : ' (fallback)');
  } else {
    mSTInfo.style.display='none';
  }
}

function refreshSubjectLabels(){
  Array.from(mSubject.options).forEach((opt, idx)=>{
    if(idx===0) return;
    const subject = opt.value;
    const count = (RAW[subject]||[]).length||0;
    opt.textContent = buildSubjectOptionLabel(subject, count);
  });
}

function beginSession(subject){
  SUBJECT=subject; qSubject.textContent=SUBJECT;
  const usingST = btnST.classList.contains('active');
  POOL=(RAW[SUBJECT]||[]).map(normalize);

  let n, minutes;
  if(usingST){
    const plan = getPlanForSubject(SUBJECT);
    n = Math.min(plan.count, POOL.length||1); minutes = plan.minutes;
  } else {
    n = Math.max(1, Math.min(parseInt(mCount.value||'50',10), POOL.length||1));
    minutes = parseInt(mMinutes.value||'0',10) || 0;
  }

  const arr = usingST ? fyShuffle([...POOL]) : (mShuffle.checked? fyShuffle([...POOL]):[...POOL]);

  QUESTIONS = arr.slice(0,n).map(q => {
    const opts = usingST ? fyShuffle([...q.options]) : (mShuffleAnswers.checked ? fyShuffle([...q.options]) : [...q.options]);
    return { ...q, options: opts, correctSet: q.correctSet, multi: q.multi };
  });

  INDEX=0; ANSWERS=Array(QUESTIONS.length).fill(null); FLAGGED=Array(QUESTIONS.length).fill(false); TEMP_SEL=Array(QUESTIONS.length).fill(null);
  MODE = usingST ? 'st' : 'test'; qModeLabel.textContent = usingST ? '(ST mode)' : '(Test mode)';
  if(usingST){ qPlan.classList.remove('hidden'); const plan = getPlanForSubject(SUBJECT); qPlan.textContent=`ST: ${n} Q ‚Ä¢ ${minutes} min`; } else { qPlan.classList.add('hidden'); }

  SCORE_CORRECT=0; QUESTIONS_ANSWERED=0; qScoreLive.textContent='Score 0/0';
  START_TS=Date.now(); qResults.classList.add('hidden');
  quiz.classList.remove('hidden'); menu.classList.add('hidden'); render();

  if(minutes>0){ startTimer(Date.now()+minutes*60*1000); } else { qTimer.textContent='--:--'; }
}

/*** CONTROLS ***/
btnTest.onclick=()=>{ btnTest.classList.add('active');btnST.classList.remove('active'); mCount.disabled=false;mMinutes.disabled=false;mShuffle.disabled=false; refreshSubjectLabels(); updateSubjectInfo(); qPlan.classList.add('hidden'); };
btnST.onclick=()=>{ btnST.classList.add('active');btnTest.classList.remove('active'); mCount.disabled=true;mMinutes.disabled=true;mShuffle.disabled=true; refreshSubjectLabels(); updateSubjectInfo(); };

mSubject.addEventListener('change', ()=>{ SUBJECT=mSubject.value; updateSubjectInfo(); });
qPrev.onclick=()=>{ if(INDEX>0){ INDEX--; render(); } };
qNext.onclick=()=>{ if(INDEX<QUESTIONS.length-1){ INDEX++; render(); } };
qBack.onclick=()=>{ ensureTimerStopped(); quiz.classList.add('hidden'); menu.classList.remove('hidden'); refreshSubjectLabels(); updateSubjectInfo(); };
logoutBtn.onclick=()=>{ sessionStorage.removeItem(AUTH_KEY); location.reload(); };

/*** LOAD QUESTIONS ***/
fetch('./Questions.json').then(r=>r.json()).then(json=>{ RAW=json; populateSubjects(); refreshSubjectLabels(); }).catch(err=>{ console.error('Failed to load Questions.json', err); mSubject.innerHTML='<option selected disabled>Failed to load Questions.json</option>'; });

document.getElementById('mStart').onclick=()=>{ const sel=mSubject.options[mSubject.selectedIndex]; if(!sel||sel.disabled){ alert('Choose a subject first.'); return; } beginSession(sel.value); };

/*** KEYS ***/
document.addEventListener('keydown',(e)=>{
  if(quiz.classList.contains('hidden')) return;
  const k=e.key;
  if(k>='1'&&k<='9'){ const idx=parseInt(k,10)-1; const q=QUESTIONS[INDEX]; if(!q) return;
    if(q.multi){
      if(isAnswered(INDEX)) return;
      const inputs=[...qOptions.querySelectorAll('input[type="checkbox"]')];
      if(inputs[idx]){ inputs[idx].click(); }
    } else {
      if(QUESTIONS[INDEX] && QUESTIONS[INDEX].options[idx]!=null){ onSelectSingle(idx); }
    }
  }
  else if(k==='f'||k==='F'){ qFlagBtn.click(); }
  else if(k==='ArrowLeft'){ qPrev.click(); }
  else if(k==='ArrowRight'){ qNext.click(); }
});
</script>

<script>
// === MENU-ONLY SIMPLIFY PATCH (non-destructive) ===
(function(){
  function byId(id){ return document.getElementById(id); }
  function closestRow(el){
    if(!el) return null;
    let n = el;
    for(let i=0;i<5 && n;i++){
      if(n.classList && (n.classList.contains('h') || n.classList.contains('v'))) return n;
      n = n.parentElement;
    }
    return el.parentElement || el;
  }
  function visible(el, on){
    if(!el) return;
    if(on){
      el.style.display = (el.__origDisplay && el.__origDisplay !== 'none') ? el.__origDisplay : '';
    } else {
      if(!el.__origDisplay){ el.__origDisplay = getComputedStyle(el).display || ''; }
      el.style.display = 'none';
    }
  }
  function setup(){
    var elCount = byId('mCount');
    var elMinutes = byId('mMinutes');
    var elShuffle = byId('mShuffle');
    var elShuffleA = byId('mShuffleAnswers');
    var elAdvance = byId('mAdvance');
    var stPlan = byId('stPlan');

    var rowQD = (function(){
      var a = closestRow(elCount);
      var b = closestRow(elMinutes);
      return (a===b? a : (a||b));
    })();
    var rowOpts = (function(){
      var a = closestRow(elShuffle);
      var b = closestRow(elShuffleA);
      var c = closestRow(elAdvance);
      return a || b || c;
    })();

    function isST(){
      var pillST = byId('pillST');
      if(pillST){
        var inp = pillST.querySelector('input[type="radio"]');
        if(inp) return inp.checked;
        if(pillST.classList && pillST.classList.contains('active')) return true;
      }
      var r = document.querySelector('input[name="m"][value="st"]');
      return r ? r.checked : false;
    }

    function apply(){
      var st = isST();
      visible(rowQD, !st);
      visible(rowOpts, !st);
      if(stPlan){ visible(stPlan, st); }
    }

    var pillTest = byId('pillTest');
    var pillST = byId('pillST');
    [pillTest, pillST].forEach(function(x){
      if(x) x.addEventListener('click', function(){ setTimeout(apply, 0); });
    });
    var radios = document.querySelectorAll('input[name="m"]');
    radios.forEach(function(r){
      r.addEventListener('change', function(){ setTimeout(apply, 0); });
    });

    apply();
    window.__menuPatchApply = apply;
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
</script>

<script>
// === THEME TOGGLE PATCH (non-destructive) ===
(function(){
  function ensureToggle(){
    var has = document.getElementById('theme');
    if(!has){
      var bars = document.querySelectorAll('.top .wrap');
      var host = bars && bars[0] ? bars[0] : document.body;
      var span = document.createElement('span');
      span.innerHTML = '<label class="pill" id="pillTheme" style="margin-left:10px;"><input id="theme" type="checkbox" /> Dark mode</label>';
      host.appendChild(span);
    }
  }
  function applyTheme(){
    try{
      var light = localStorage.getItem('light') === '1';
      document.body.classList.toggle('light', light);
      var theme = document.getElementById('theme');
      var pill = document.getElementById('pillTheme');
      if(theme){ theme.checked = light; }
      if(pill){ if(light) pill.classList.add('active'); else pill.classList.remove('active'); }
    }catch(e){}
  }
  function hook(){
    var theme = document.getElementById('theme');
    if(theme){
      theme.addEventListener('change', function(e){
        var light = !!e.target.checked;
        try{ localStorage.setItem('light', light ? '1' : '0'); }catch(_){}
        applyTheme();
      });
    }
  }
  function ensureLightCSS(){
    var hasLight = document.querySelector('style[data-theme-light]');
    if(!hasLight){
      var s = document.createElement('style');
      s.setAttribute('data-theme-light','1');
      s.textContent = 'body.light{--bg:#f6f7f9;--panel:#ffffff;--soft:#f2f4f7;--text:#0b0b0b;--muted:#4b5563;--border:#e5e7eb;--accent:#16a34a;--accent-soft:#e6f6ea;--exam:#9ca3af;--qbox:#eef6ff;--qtext:#0b0b0b}';
      document.head.appendChild(s);
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      ensureToggle(); ensureLightCSS(); applyTheme(); hook();
    });
  } else {
    ensureToggle(); ensureLightCSS(); applyTheme(); hook();
  }
})();
</script>


<style data-theme-iconbtn>
.iconbtn{display:inline-flex;align-items:center;justify-content:center;width:36px;height:36px;border:1px solid var(--border);background:var(--soft);border-radius:10px;cursor:pointer;font-size:16px}
.iconbtn:hover{filter:brightness(1.05)}
</style>
<script>
// === THEME ICON BUTTON PATCH ===
(function(){
  function applyTheme(){
    var light = localStorage.getItem('light') === '1';
    document.body.classList.toggle('light', light);
    var btn = document.getElementById('themeBtn');
    if(btn){ btn.textContent = light ? '‚òÄÔ∏è' : 'üåô'; btn.title = light ? 'Switch to Dark' : 'Switch to Light'; }
  }
  function ensureIconInTopbar(){
    // hide any legacy checkbox toggle if present
    var old = document.getElementById('pillTheme');
    if(old) old.style.display = 'none';
    var oldInput = document.getElementById('theme');
    if(oldInput){ var host = oldInput.closest('label'); if(host) host.style.display='none'; }

    // find top bar right area (use the first .top .wrap, append at the end)
    var bars = document.querySelectorAll('.top .wrap');
    var host = bars && bars[0] ? bars[0] : document.body;
    // if there's more than one .top .wrap (menu vs quiz), add to all
    (bars.length ? bars : [host]).forEach(function(h){
      var existing = h.querySelector('#themeBtn');
      if(existing) return;
      var btn = document.createElement('button');
      btn.id = 'themeBtn';
      btn.className = 'iconbtn';
      btn.style.marginLeft = '10px';
      btn.addEventListener('click', function(){
        var light = localStorage.getItem('light') === '1';
        try{ localStorage.setItem('light', light ? '0' : '1'); }catch(_){}
        applyTheme();
      });
      // place near the right side if layout uses space-between
      h.appendChild(btn);
    });
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){ ensureIconInTopbar(); applyTheme(); });
  } else {
    ensureIconInTopbar(); applyTheme();
  }
})();
</script>


<style data-theme-iconbtn-2>
.iconbtn{display:inline-flex;align-items:center;justify-content:center;width:36px;height:36px;border:1px solid var(--border);background:var(--soft);border-radius:10px;cursor:pointer;font-size:16px}
.iconbtn:hover{filter:brightness(1.05)}
.themewrap{display:inline-flex;align-items:center;gap:8px;margin-left:10px}
.themelabel{font-size:12px;color:var(--muted)}
</style>
<script>
// === THEME TOGGLE TOP-RIGHT + LABEL PATCH ===
(function(){
  function ensureContainers(){
    var bars = document.querySelectorAll('.top .wrap');
    bars.forEach(function(wrap){
      // Prefer the right-side group: last direct child with class "h"
      var rightGroup = wrap.querySelector(':scope > .h:last-child') || wrap;
      // Remove old pill/legacy toggles if any
      var old = rightGroup.querySelector('#pillTheme');
      if(old) old.style.display='none';
      // Create or move the theme wrapper
      var wrapEl = rightGroup.querySelector('#themeWrap');
      if(!wrapEl){
        wrapEl = document.createElement('span');
        wrapEl.id = 'themeWrap';
        wrapEl.className = 'themewrap';
        var lbl = document.createElement('span');
        lbl.id = 'themeLabel';
        lbl.className = 'themelabel';
        lbl.textContent = 'Light / Dark Mode';
        var btn = document.createElement('button');
        btn.id = 'themeBtn';
        btn.className = 'iconbtn';
        rightGroup.appendChild(wrapEl);
        wrapEl.appendChild(lbl);
        wrapEl.appendChild(btn);
      } else {
        // Ensure it sits at the end of the right group
        rightGroup.appendChild(wrapEl);
      }
    });
  }
  function applyTheme(){
    var light = localStorage.getItem('light') === '1';
    document.body.classList.toggle('light', light);
    // Update all buttons
    document.querySelectorAll('#themeBtn').forEach(function(btn){
      btn.textContent = light ? '‚òÄÔ∏è' : 'üåô';
      btn.title = light ? 'Switch to Dark' : 'Switch to Light';
    });
  }
  function hook(){
    document.querySelectorAll('#themeBtn').forEach(function(btn){
      btn.onclick = function(){
        var light = localStorage.getItem('light') === '1';
        try{ localStorage.setItem('light', light ? '0' : '1'); }catch(_){}
        applyTheme();
      };
    });
  }
  function hideLegacy(){
    // Hide any old checkbox label anywhere
    var old = document.getElementById('pillTheme');
    if(old) old.style.display='none';
    var oldInput = document.getElementById('theme');
    if(oldInput){ var host = oldInput.closest('label'); if(host) host.style.display='none'; }
  }
  function init(){
    hideLegacy();
    ensureContainers();
    applyTheme();
    hook();
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>


<style data-theme-iconbtn-3>
.iconbtn{display:inline-flex;align-items:center;justify-content:center;width:36px;height:36px;border:1px solid var(--border);background:var(--soft);border-radius:10px;cursor:pointer;font-size:16px}
.iconbtn:hover{filter:brightness(1.05)}
.themewrap{display:inline-flex;align-items:center;gap:8px;margin-left:10px}
.themelabel{font-size:12px;color:var(--muted);white-space:nowrap}
</style>
<script>
// === THEME TOGGLE TOP-RIGHT (FIXED) ===
(function(){
  function applyTheme(){
    var light = localStorage.getItem('light') === '1';
    document.body.classList.toggle('light', light);
    document.querySelectorAll('#themeBtn').forEach(function(btn){
      btn.textContent = light ? '‚òÄÔ∏è' : 'üåô';
      btn.title = light ? 'Switch to Dark' : 'Switch to Light';
      btn.setAttribute('aria-label', light ? 'Switch to Dark' : 'Switch to Light');
    });
  }
  function mountInBar(wrap){
    // choose right-most group; if none, create a right group
    var rightGroup = wrap.querySelector(':scope > .h:last-child');
    if(!rightGroup){
      rightGroup = document.createElement('div');
      rightGroup.className = 'h';
      wrap.appendChild(rightGroup);
    }
    // create themewrap
    var tw = document.createElement('span');
    tw.id = 'themeWrap';
    tw.className = 'themewrap';
    var lbl = document.createElement('span');
    lbl.id = 'themeLabel';
    lbl.className = 'themelabel';
    lbl.textContent = 'Light / Dark Mode';
    var btn = document.createElement('button');
    btn.id = 'themeBtn';
    btn.className = 'iconbtn';
    btn.addEventListener('click', function(){
      var light = localStorage.getItem('light') === '1';
      try { localStorage.setItem('light', light ? '0' : '1'); } catch(_) {}
      applyTheme();
    });
    tw.appendChild(lbl);
    tw.appendChild(btn);
    rightGroup.appendChild(tw);
  }
  function init(){
    // Remove any existing injected theme controls
    document.querySelectorAll('#themeWrap, #themeBtn').forEach(function(n){
      if(n && n.parentElement) n.parentElement.removeChild(n);
    });
    // Hide any legacy checkbox control
    var old = document.getElementById('pillTheme'); if(old) old.style.display='none';
    var oldInput = document.getElementById('theme'); if(oldInput){ var host = oldInput.closest('label'); if(host) host.style.display='none'; }
    // Require actual top bars to exist; do not append to body
    var bars = document.querySelectorAll('.top .wrap');
    if(!bars || bars.length === 0){ return; }
    bars.forEach(function(wrap){ mountInBar(wrap); });
    applyTheme();
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>


<style data-theme-iconbtn-struct>
.iconbtn{display:inline-flex;align-items:center;justify-content:center;width:36px;height:36px;border:1px solid var(--border);background:var(--bg-soft);border-radius:10px;cursor:pointer;font-size:16px}
.iconbtn:hover{filter:brightness(1.05)}
.themewrap{display:inline-flex;align-items:center;gap:8px;margin-left:10px}
.themelabel{font-size:12px;color:var(--muted);white-space:nowrap}
.themewrap.menu{align-self:flex-end}
</style>
<script>
(function(){
  function applyTheme(){
    var light = localStorage.getItem('light') === '1';
    document.body.classList.toggle('light', light);
    document.querySelectorAll('#themeBtn').forEach(function(btn){
      btn.textContent = light ? '‚òÄÔ∏è' : 'üåô';
      btn.title = light ? 'Switch to Dark' : 'Switch to Light';
      btn.setAttribute('aria-label', light ? 'Switch to Dark' : 'Switch to Light');
    });
  }
  function makeControl(){
    var wrap = document.createElement('span');
    wrap.id = 'themeWrap';
    wrap.className = 'themewrap';
    var lbl = document.createElement('span');
    lbl.id = 'themeLabel';
    lbl.className = 'themelabel';
    lbl.textContent = 'Light / Dark Mode';
    var btn = document.createElement('button');
    btn.id = 'themeBtn';
    btn.className = 'iconbtn';
    btn.addEventListener('click', function(){
      var light = localStorage.getItem('light') === '1';
      try{ localStorage.setItem('light', light ? '0' : '1'); }catch(_){}
      applyTheme();
    });
    wrap.appendChild(lbl);
    wrap.appendChild(btn);
    return wrap;
  }
  function mountMenu(){
    var menu = document.querySelector('#menu .vstack');
    if(!menu) return;
    // remove existing
    var old = menu.querySelector('#themeWrap'); if(old) old.remove();
    var ctl = makeControl();
    ctl.classList.add('menu');
    menu.insertBefore(ctl, menu.firstChild);
  }
  function mountQuiz(){
    var right = document.querySelector('#quiz .topbar .container .header > .hstack:last-child');
    if(!right) return;
    var old = right.querySelector('#themeWrap'); if(old) old.remove();
    var ctl = makeControl();
    right.appendChild(ctl);
  }
  function hideLegacy(){
    var old = document.getElementById('pillTheme'); if(old) old.style.display='none';
    var oldInput = document.getElementById('theme'); if(oldInput){ var host = oldInput.closest('label'); if(host) host.style.display='none'; }
  }
  function init(){
    hideLegacy();
    mountMenu();
    mountQuiz();
    applyTheme();
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>


<script>
// === TEST MODE FEEDBACK RESTORE PATCH ===
(function(){
  function patch(){
    if(typeof window.showFeedbackThenAdvance !== 'function') return;
    // Override to ensure feedback is visible BEFORE any auto-advance.
    window.showFeedbackThenAdvance = function(){
      if(typeof MODE !== 'undefined' && MODE !== 'test'){
        // Keep original behavior for ST/exam-like modes: no instant feedback
        // Fallback to simple record + render
      }
      var q = (typeof QUESTIONS!=='undefined') ? QUESTIONS[INDEX] : null;
      if(!q) return;
      // lock inputs
      var inputs = document.querySelectorAll('#opts input');
      inputs.forEach(function(inp){ inp.disabled = true; });
      // compute correctness
      var ok = (typeof isCorrect==='function') ? isCorrect(INDEX) : false;
      // display feedback block
      try{
        var correctText = q.multi ? Array.from(q.correctSet).join(', ') : q.correct;
        if(typeof showFb === 'function'){ showFb(ok, correctText, q.explanation, false); }
      }catch(e){}
      // update running score for test mode
      try{
        SEEN++; if(ok) COR++; if(typeof score!=='undefined') score.textContent = 'Score '+COR+'/'+SEEN;
      }catch(e){}
      // refresh pager colors for current item
      try{ if(typeof rebuildPager==='function') rebuildPager(); }catch(e){}
      // Decide on advancing
      var advSel = document.getElementById('mAdvance');
      var delay = advSel ? parseInt(advSel.value||'0',10)||0 : 0;
      if(typeof MODE !== 'undefined' && MODE==='test' && delay>0){
        setTimeout(function(){
          if(INDEX < QUESTIONS.length-1){ INDEX++; }
          if(typeof render==='function') render();
        }, delay);
      } else {
        // Stay on current question to let the user see feedback; do not call render() here.
      }
    };
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', patch);
  } else {
    patch();
  }
})();
</script>


<script>
// === FORCE FEEDBACK BEFORE ADVANCE (CAPTURE INTERCEPT) ===
(function(){
  function textOfCorrect(q){
    try{
      if(q.multi){ return Array.from(q.correctSet).join(', '); }
      return q.correct;
    }catch(e){ return ''; }
  }
  function lockInputs(){
    document.querySelectorAll('#opts input').forEach(function(i){ i.disabled = true; });
  }
  function updateScore(ok){
    try{
      SEEN++; if(ok) COR++;
      if(typeof score!=='undefined'){ score.textContent = 'Score '+COR+'/'+SEEN; }
    }catch(e){}
  }
  function doAdvanceIfNeeded(){
    var advSel = document.getElementById('mAdvance');
    var delay = advSel ? parseInt(advSel.value||'0',10)||0 : 0;
    if(MODE !== 'test' || delay<=0) return;  // don't auto-advance if off
    setTimeout(function(){
      if(INDEX < QUESTIONS.length-1){ INDEX++; }
      if(typeof render==='function') render();
    }, delay);
  }
  function handleRadioClick(ev){
    if(!document.getElementById('opts')) return;
    if(!window.QUESTIONS || !QUESTIONS.length) return;
    if(typeof MODE==='undefined' || MODE!=='test') return; // only for Test mode
    var q = QUESTIONS[INDEX];
    if(!q || q.multi) return; // radios only for single-choice
    // if already answered, let default flow
    if(Array.isArray(ANS) && ANS[INDEX] !== null){ return; }
    // prevent original handlers
    ev.preventDefault(); ev.stopImmediatePropagation();
    // determine index of clicked radio among options
    var inputs = Array.from(document.querySelectorAll('#opts input[type="radio"]'));
    var idx = inputs.indexOf(ev.target);
    if(idx<0) return;
    // mark selection and tick the UI
    ANS[INDEX] = idx;
    inputs.forEach(function(el,i){ el.checked = (i===idx); });
    // show feedback, lock, score, maybe advance
    try{ var ok = (typeof isCorrect==='function') ? isCorrect(INDEX) : false;
         if(typeof showFb==='function'){ showFb(ok, textOfCorrect(q), q.explanation, false); } }catch(e){}
    lockInputs();
    updateScore(ok);
    try{ if(typeof rebuildPager==='function') rebuildPager(); }catch(e){}
    doAdvanceIfNeeded();
    // do NOT call render() now ‚Äî keep feedback visible
  }
  function handleConfirmClick(ev){
    if(typeof MODE==='undefined' || MODE!=='test') return; // only adjust Test mode
    if(!window.QUESTIONS || !QUESTIONS.length) return;
    var q = QUESTIONS[INDEX];
    if(!q || !q.multi) return; // only for multi-choice confirm
    // prevent original fast-advance, we'll do it after feedback
    ev.preventDefault(); ev.stopImmediatePropagation();
    var checks = Array.from(document.querySelectorAll('#opts input[type="checkbox"]'));
    var sel = checks.map((c,i)=>c.checked?i:null).filter(i=>i!==null);
    if(sel.length===0) return; // nothing selected
    ANS[INDEX] = sel.slice();
    // show feedback, lock, score, maybe advance
    try{ var ok = (typeof isCorrect==='function') ? isCorrect(INDEX) : false;
         if(typeof showFb==='function'){ showFb(ok, textOfCorrect(q), q.explanation, false); } }catch(e){}
    lockInputs();
    updateScore(ok);
    try{ if(typeof rebuildPager==='function') rebuildPager(); }catch(e){}
    doAdvanceIfNeeded();
  }
  function init(){
    // Capture phase listeners so they run BEFORE original handlers
    document.addEventListener('click', function(ev){
      var t = ev.target;
      if(!(t instanceof Element)) return;
      if(t.matches('#opts input[type="radio"]')){ handleRadioClick(ev); return; }
      if(t.matches('#confirm')){ handleConfirmClick(ev); return; }
    }, true);
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>


<style data-v16-inline-feedback>
/* v1.6-style inline answer feedback */
.opts li.correct { color: var(--ok); font-weight: 600; }
.opts li.incorrect { color: var(--bad); }
.opts li .tag { display:inline-block; min-width:18px; text-align:center; border:1px solid var(--border); border-radius:6px; padding:2px 6px; margin-right:6px; font-size:11px; color:var(--muted); }
.opts li.correct .tag { border-color: var(--ok); color: var(--ok); }
.opts li.incorrect .tag { border-color: var(--bad); color: var(--bad); }
</style>

<script>
// === v1.6-style inline feedback coloring for Test mode ===
(function(){
  function markInline(q){
    if(typeof MODE==='undefined' || MODE!=='test') return;
    var list = document.getElementById('opts'); if(!list) return;
    var items = Array.from(list.querySelectorAll('li'));
    // clear previous marks
    items.forEach(function(li){ li.classList.remove('correct','incorrect'); });
    // Build text arrays
    var texts = items.map(function(li){
      var t = li.textContent || '';
      // if we added a tag span, remove from compare
      var tag = li.querySelector('.tag');
      if(tag){ t = t.replace(tag.textContent,'').trim(); }
      return t.trim();
    });
    if(q.multi){
      // Selected indices
      var sel = Array.isArray(ANS[INDEX]) ? ANS[INDEX] : [];
      var correctSet = q.correctSet;
      items.forEach(function(li, i){
        var t = texts[i];
        var isCorrect = correctSet && correctSet.has(String(t));
        var isSelected = sel.includes(i);
        if(isCorrect) li.classList.add('correct');
        if(isSelected && !isCorrect) li.classList.add('incorrect');
      });
    } else {
      // single choice
      var chosen = ANS[INDEX];
      var correctText = q.correct;
      items.forEach(function(li, i){
        var t = texts[i];
        if(t === String(correctText)) li.classList.add('correct');
        if(i === chosen && t !== String(correctText)) li.classList.add('incorrect');
      });
    }
  }
  // Hook into existing render cycle after user answers
  var _showFeedbackThenAdvance = window.showFeedbackThenAdvance;
  window.showFeedbackThenAdvance = function(){
    if(!_showFeedbackThenAdvance){
      return;
    }
    // Let our intercept layer (if present) set ANS first, then decorate and show feedback
    var q = (typeof QUESTIONS!=='undefined') ? QUESTIONS[INDEX] : null;
    if(q){
      // Prevent immediate advance to ensure visibility when auto-advance is 0
      // Decoration happens before calling the original for safety
      markInline(q);
    }
    // Call original to handle feedback box + scoring + possible auto-advance
    try{ _showFeedbackThenAdvance(); }catch(e){}
    // Re-apply decoration in case original re-rendered
    if(q){ try{ markInline(q); }catch(e){} }
  };

  // Also decorate when rendering an already-answered question
  var _render = window.render;
  window.render = function(){
    var r = _render ? _render() : undefined;
    try{
      if(typeof MODE!=='undefined' && MODE==='test'){
        var q = (typeof QUESTIONS!=='undefined') ? QUESTIONS[INDEX] : null;
        if(q && (Array.isArray(ANS[INDEX]) ? ANS[INDEX].length>0 : ANS[INDEX]!==null)){
          markInline(q);
        }
      }
    }catch(e){}
    return r;
  };
})();
</script>

</body></html>
